package carrotmq

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"net"
	"sync"
	"testing"
	"time"

	"github.com/aleybovich/carrot-mq/internal"

	amqp "github.com/rabbitmq/amqp091-go"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var testRand = rand.New(rand.NewSource(time.Now().UnixNano())) // For unique names
// testServerPortCounter is a global counter to assign unique ports to test servers.
var testServerPortCounter = 5800 // Starting port number, different from previous example
var portCounterMutex sync.Mutex

func getNextTestPort() string {
	portCounterMutex.Lock()
	defer portCounterMutex.Unlock()
	port := testServerPortCounter
	testServerPortCounter++
	return fmt.Sprintf(":%d", port)
}

// Helper to generate unique names for exchanges, queues, etc.
func uniqueName(prefix string) string {
	return fmt.Sprintf("%s-%d-%d", prefix, time.Now().UnixNano(), testRand.Intn(10000))
}

func setupTestServer(t *testing.T, opts ...ServerOption) (addr string, cleanup func()) {
	internal.IsTerminal = true // Force colorized output for server logs during tests
	addr = getNextTestPort()
	s := NewServer(opts...) // Uses default internal logger

	// Channel to signal when server goroutine exits
	serverDone := make(chan struct{})

	go func() {
		defer close(serverDone)
		if err := s.Start(addr); err != nil {
			// Only log if it's not the expected closed listener error
			if !errors.Is(err, net.ErrClosed) {
				t.Logf("Test server failed to start on %s: %v", addr, err)
			}
		}
	}()

	// Wait for server to be ready using IsReady instead of hardcoded sleep
	readyTimeout := time.After(1 * time.Second)
	ticker := time.NewTicker(10 * time.Millisecond)
	defer ticker.Stop()
	
	ready := false
	for !ready {
		select {
		case <-readyTimeout:
			t.Fatalf("Timeout waiting for test server to be ready on %s", addr)
		case <-ticker.C:
			if s.IsReady() {
				// Server is ready
				ready = true
			}
		}
	}

	cleanup = func() {
		err := s.Shutdown(context.TODO())
		if err != nil {
			t.Logf("Error shutting down test server on %s: %v", addr, err)
		}

		// Wait for server goroutine to exit with timeout
		select {
		case <-serverDone:
			// Server exited cleanly
		case <-time.After(1 * time.Second):
			t.Logf("Warning: Server goroutine did not exit within timeout for %s", addr)
		}
	}

	return addr, cleanup
}

// t_publishMessage publishes a single message.
func t_publishMessage(t *testing.T, ch *amqp.Channel, exchange, key, body string, mandatory bool, pub amqp.Publishing) {
	t.Helper()
	pub.Body = []byte(body)
	err := ch.Publish(exchange, key, mandatory, false /* immediate */, pub)
	require.NoError(t, err, "Failed to publish message")
}

// t_consumeMessage starts a consumer and returns the delivery channel and the actual consumer tag.
// If consumerTag is empty, one will be generated by the client library.
func t_consumeMessage(t *testing.T, ch *amqp.Channel, queueName string, consumerTag string, autoAck bool) (deliveries <-chan amqp.Delivery, actualConsumerTag string) {
	t.Helper()
	// If consumerTag is empty, the client library generates one.
	// We need to capture the server-generated one if our server also generates one for empty client tags.
	// For now, let's assume client lib handles empty tag generation if server doesn't explicitly return it in ConsumeOk for empty client tag.
	// The amqp091-go library's Consume method does not directly return the server-generated tag if the client provided an empty one.
	// The server's ConsumeOk frame sends the actual tag. The client library uses this.
	// So, if client sends empty, it will use a lib-generated one, and server will see that.
	// If client sends specific, server sees that.
	// For tests, we usually provide a specific tag or let lib generate one and don't need to assert server-generated one unless it's part of the test.

	d, err := ch.Consume(
		queueName,
		consumerTag, // consumer
		autoAck,     // auto-ack
		false,       // exclusive
		false,       // no-local
		false,       // no-wait
		nil,         // args
	)
	require.NoError(t, err, "Failed to start consumer")

	// To get the actual consumer tag used (especially if client sent empty and server generated one),
	// we'd typically rely on the ConsumeOk frame. The client library handles this internally.
	// For testing purposes, if we provide a consumerTag, that's the one we expect.
	// If we provide empty, the client lib generates one like "ctag-......".
	// Our server also generates one if client sends empty. The client library's `Consume`
	// method doesn't directly expose the *server-generated* tag if the client initially sent an empty tag.
	// This helper will return the tag provided by the test, or an empty string if the test provided empty.
	// The server's `Basic.ConsumeOk` sends the *actual* tag, which the client library then uses.
	return d, consumerTag
}

// t_expectChannelClose sets up NotifyClose and asserts the expected error.
func t_expectChannelClose(t *testing.T, ch *amqp.Channel, expectedCode int, expectedReasonContains string) {
	t.Helper()
	closedCh := make(chan *amqp.Error, 1)
	ch.NotifyClose(closedCh)

	select {
	case amqpErr, isOpen := <-closedCh:
		require.True(t, isOpen, "NotifyClose channel was unexpectedly closed without sending an error")
		require.NotNil(t, amqpErr, "Should receive a channel close error")
		assert.Equal(t, expectedCode, amqpErr.Code, "AMQP error code mismatch")
		if expectedReasonContains != "" {
			assert.Contains(t, amqpErr.Reason, expectedReasonContains, "Error reason mismatch")
		}
	case <-time.After(2 * time.Second): // Reasonably long timeout
		// Try another operation to confirm channel state as a fallback
		errAfter := ch.ExchangeDeclare(uniqueName("probe-ex-on-close"), "direct", false, false, false, false, nil)
		require.Error(t, errAfter, "Channel should be closed, but operation succeeded")
		if amqpErr, ok := errAfter.(*amqp.Error); ok {
			// This error might be a generic "channel is closed" rather than the specific one we expected.
			t.Logf("Subsequent operation failed with AMQP error: Code %d, Reason: %s", amqpErr.Code, amqpErr.Reason)
			if amqpErr.Code == expectedCode { // If the subsequent error matches, it's a pass
				if expectedReasonContains != "" {
					assert.Contains(t, amqpErr.Reason, expectedReasonContains, "Error reason mismatch on subsequent op")
				}
			} else {
				assert.Fail(t, "Timeout waiting for channel close notification with expected code/reason. Subsequent op error did not match.")
			}
		} else {
			assert.Contains(t, errAfter.Error(), "channel/connection is not open", "Error should indicate channel is closed")
			assert.Fail(t, "Timeout waiting for channel close notification. Subsequent op error was not an AMQP error.")
		}
	}
}

// t_expectNoChannelClose ensures no channel close notification is received within a duration.
func t_expectNoChannelClose(t *testing.T, ch *amqp.Channel, duration time.Duration) {
	t.Helper()
	closedCh := make(chan *amqp.Error, 1)
	ch.NotifyClose(closedCh)

	select {
	case amqpErr := <-closedCh:
		if amqpErr != nil { // It's possible for a nil to be sent if channel closes cleanly before NotifyClose is setup
			assert.Fail(t, "Channel closed unexpectedly", "Error: %v", amqpErr)
		}
	case <-time.After(duration):
		// Expected: no close notification
	}
}

// t_expectMessage waits for a message and asserts its body and optionally redelivered status.
// Returns the received message.
func t_expectMessage(t *testing.T, deliveries <-chan amqp.Delivery, expectedBody string, expectedRedelivered *bool, timeout time.Duration) amqp.Delivery {
	t.Helper()
	select {
	case msg, ok := <-deliveries:
		require.True(t, ok, "Deliveries channel was closed unexpectedly")
		assert.Equal(t, expectedBody, string(msg.Body), "Message body mismatch")
		if expectedRedelivered != nil {
			assert.Equal(t, *expectedRedelivered, msg.Redelivered, "Message redelivered status mismatch")
		}
		return msg
	case <-time.After(timeout):
		assert.Fail(t, "Timeout waiting for message", "Expected body: %s", expectedBody)
		return amqp.Delivery{} // Should not be reached if FailNow is used by assert.Fail
	}
}

// t_expectNoMessage ensures no message is received within a duration.
func t_expectNoMessage(t *testing.T, deliveries <-chan amqp.Delivery, duration time.Duration) {
	t.Helper()
	select {
	case msg := <-deliveries:
		assert.Fail(t, "Received message unexpectedly", "Body: %s", string(msg.Body))
	case <-time.After(duration):
		// Expected: no message
	}
}

// t_setupQueueAndConsumer is a common setup for ack/nack/reject tests.
func t_setupQueueAndConsumer(t *testing.T, ch *amqp.Channel, queueName string, autoAck bool) (q amqp.Queue, deliveries <-chan amqp.Delivery, consumerTag string) {
	t.Helper()
	var err error
	q, err = ch.QueueDeclare(queueName, false, false, false, false, nil)
	require.NoError(t, err, "Failed to declare queue %s", queueName)

	// Bind to default exchange for simplicity in these tests
	err = ch.QueueBind(q.Name, q.Name, "", false, nil)
	require.NoError(t, err, "Failed to bind queue %s", q.Name)

	ctag := uniqueName("consumer")
	deliveries, actualConsumerTag := t_consumeMessage(t, ch, q.Name, ctag, autoAck)
	require.Equal(t, ctag, actualConsumerTag, "Consumer tag mismatch")
	return q, deliveries, actualConsumerTag
}
